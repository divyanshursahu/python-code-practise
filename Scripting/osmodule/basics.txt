import os 

# os.name - to get the name of the OS you are running the command.

print(f"The Os name is: {os.name}")

#  os.environ, os.getenv() and os.putenv() - The os.environ value is known as a mapping object that returns a dictionary of the user’s environmental variables. You may not know this, but every time you use your computer, some environment variables are set. These can give you valuable information, such as number of processors, type of CPU, the computer name, etc.

print(f"printing OS envs: {os.environ} \n")

print(f"Getting OS envs value: {os.getenv('USER')} \n")

# os.chdir() and os.getcwd()

print(f"Print the current working directory: {os.getcwd()} \n")
# print(f"change the workding directory: {os.chdir(r'/Users/divyanshusahu/Downloads/')} \n")  # output will be none onlt r' -- signifies raw string

print(f"Print the current working directory: {os.getcwd()} \n")

# os.mkdir() and os.makedirs() -- os.mkdir() allows us to create a single folder. os.makedirs() function will create all the intermediate folders in a path if they don’t already exist. Basically this means that you can created a path that has nested folders in it. I find myself doing this a lot when I create a log file that is in a dated folder structure, like Year/Month/Day. Let’s look at an example:


#os.mkdir('Test1') # will make folder in cwd it is making in downloads folder as we changed the directory in above command
path = r'/Users/divyanshusahu/Downloads/Github/python-code-practise/Scripting/Test3'
os.mkdir(path)

os.makedirs('Test/testnested')  # This will just make directory single or multiple but not files in the directory

# os.remove() and os.rmdir() -- The os.remove() and os.rmdir() functions are used for deleting files and directories respectively. Let’s look at an example of os.remove():

os.remove("test.txt")

#This code snippet will attempt to remove a file named test.txt from your current working directory. If it cannot find the file, you will likely receive some sort of error. You will also receive an error if the file is in use (i.e. locked) or you don’t have permission to delete the file. You might also want to check out os.unlink, which does the same thing. The term unlink is the traditional Unix name for this procedure.

# example of os.rmdir():

os.rmdir("pytest")

# The code above will attempt to remove a directory named pytest from your current working directory. If it’s successful, you will see that the directory no longer exists. An error will be raised if the directory does not exist, you do not have permission to remove it or if the directory is not empty. You might also want to take a look at os.removedirs() which can remove nested empty directories recursively.

os.rename(src, dst)

# The os.rename() function will rename a file or folder. Let’s take a look at an example where we rename a file:

# we tell os.rename to rename a file named test.txt to pytest.txt. This occurs in our current working directory. You will see an error occur if you try to rename a file that doesn’t exist or that you don’t have the proper permission to rename the file.

# There is also an os.renames function that recursively renames a directory or file.

os.startfile()

#The os.startfile() method allows us to “start” a file with its associated program. In other words, we can open a file with it’s associated program, just like when you double-click a PDF and it opens in Adobe Reader. Let’s give it a try!

#  os.startfile(r'C:\Users\mike\Documents\labels.pdf')

# os.walk()  - The os.walk() method gives us a way to iterate over a root level path. What this means is that we can pass a path to this function and get access to all its sub-directories and files. Let’s use one of the Python folders that we have handy to test this function with. We’ll use: C:\Python27\Tools

``` >>> path = r'C:\Python27\Tools'
>>> for root, dirs, files in os.walk(path):
        print(root)

C:\Python27\Tools
C:\Python27\Tools\i18n
C:\Python27\Tools\pynche
C:\Python27\Tools\pynche\X
C:\Python27\Tools\Scripts
C:\Python27\Tools\versioncheck
C:\Python27\Tools\webchecker

```

# If you want, you can also loop over dirs and files too. Here’s one way to do it:

for root, dirs, files in os.walk(path):
        print(root)
        for _dir in dirs:
            print(_dir)
        for _file in files:
            print(_file)


os.path
The os.path sub-module of the os module has lots of great functionality built into it. We’ll be looking at the following functions:

basename
dirname
exists
isdir and isfile
join
split

os.system(command)  - to run system commands